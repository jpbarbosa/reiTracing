#ifndef _H_Cube#define _H_Cube/* Needed libraries. */#include <cmath>/* Defines the needed classes and their headers. */class Ray;#include "BasicStructures.h"#include "Object.h"/* Header for the Sphere class. */class Cube : public Object{private:    /* - - - - - - - - - - - - ATTRIBUTES - - - - - - - - - -*/    /* A normal vector for each face of the cube. They are:     * Front, Right, Bottom, Left, Back, Top.     *     * These is not an random choice. We are assuring that the vertixes, from     * one to six, can be selected as points belonging to each face.     */    vector normals[6];    /* The front face will be constituted by the vertixes p1, p2, p3, p4, order from     * top left and clockwise.     * The back face will have the other vertixes, by the same order and starting by     * p5.     */    point vertixes[8];    /* In order to keep the compatibility with all the other objects and don't     * introduce new parameters on the newDirection() method, each time we call     * intersects(), in case we find an intersection, we will place on this vector     * the normal vector corresponding to the intersected face.     * Then, if the cube is selected as the closest intersection, we will know for     * sure which normal is to be used.     */    vector intersectionNormal;    /* The variable maxSide is used to know which is the largest side of the cube.     * This will be quite useful for when we are performing intersections, we may     * know the size of an imaginary sphere that covers all the cube. As an     * intersection with a sphere is much easier and lighter to calculate, we will     * only perform an intersection with the cube if the ray intersects this     * same sphere.     */    double maxSide;public:    /* - - - - - - - CONSTRUCTOR & DESTRUCTOR - - - - - - - -*/    /* Constructor & destructor. */    explicit Cube(double x, double y, double z, double xSide, double ySide, double zSide, double rC, double gC, double bC);    explicit Cube();    ~Cube();    /* - - - - - - - OTHER METHODS - - - - - - - -*/    /* Determinates whether the ray intersects this sphere or not. */    bool intersects(Ray &ray, double &rT0, double &rT1);    bool intersectsSphere(Ray &ray);    void newDirection(Ray &ray, double &t);    bool refractionRedirection(Ray &ray, double t0, double t1);    void intersectionPointNormal(Ray &ray, vector &normalInt);    /* - - - - - - - GETTERS & SETTERS - - - - - - - -*/    vector getNormalFront();    vector getNormalBack();    vector getNormalRight();    vector getNormalLeft();    vector getNormalBottom();    vector getNormalTop();    void setNormalFront(vector v);    void setNormalBack(vector v);    void setNormalRight(vector v);    void setNormalLeft(vector v);    void setNormalBottom(vector v);    void setNormalTop(vector v);};#endif